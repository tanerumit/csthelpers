% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/climate_surface_base.R
\name{climate_surface_base}
\alias{climate_surface_base}
\title{Generate a Climate Response Surface Base Plot}
\usage{
climate_surface_base(
  data = NULL,
  x_var = NULL,
  y_var = NULL,
  z_var = NULL,
  threshold = NULL,
  title = "Climate Response Surface",
  x_label = expression(Delta ~ "Precipitation"),
  y_label = expression(Delta ~ "Temperature"),
  x_suffix = "\%",
  y_suffix = "Â°C",
  failure_dir = 1,
  x_breaks = NULL,
  y_breaks = NULL,
  n_contours = 25,
  z_limits = NULL,
  panel_size_in = 6,
  legend_barheight_in = 0.25,
  text_size = 0.7,
  facet = FALSE,
  facet_by = NULL,
  facet_levels = NULL
)
}
\arguments{
\item{data}{A data.frame containing the stress-test grid.
Must include numeric columns for \code{x_var}, \code{y_var}, and \code{z_var}. If
\code{facet=TRUE}, must also include \code{facet_by}.}

\item{x_var, y_var, z_var}{Character scalars. Column names in \code{data} for the x-axis
driver, y-axis driver, and response (impact) variable, respectively.}

\item{threshold}{Numeric scalar. Response threshold used to:
(i) draw the boundary contour line, and (ii) place the single pure-white step in the
diverging palette. If \code{NULL}, the function infers the threshold from the baseline
point where \code{x_var \eqn{\approx} 0} and \code{y_var \eqn{\approx} 0}. If no baseline
is present, \code{threshold} must be provided.}

\item{title}{Plot title.}

\item{x_label, y_label}{Axis titles. Can be strings or \code{\link[base:plotmath]{plotmath}}
expressions (defaults are suitable for delta precipitation/temperature).}

\item{failure_dir}{Integer, either \code{1} or \code{-1}. Controls which side of the
threshold is shown as "failure" (red) vs "safe" (blue):
\itemize{
  \item \code{failure_dir = 1}: higher \code{z_var} relative to \code{threshold} tends
    toward "safe" (blue) and lower tends toward "failure" (red).
  \item \code{failure_dir = -1}: the mapping is reversed.
}
Use this to align color semantics with your impact definition (e.g., higher values can
be worse for some metrics).}

\item{x_breaks, y_breaks}{Optional numeric vectors of tick/level values for x and y axes.
If \code{NULL}, uses sorted unique values from \code{data[[x_var]]} and \code{data[[y_var]]}.
Axis limits are set to \code{range(x_breaks)} and \code{range(y_breaks)}.}

\item{n_contours}{Integer \eqn{\ge 3}. Target number of contour bins (filled steps).
Internally used to generate a set of bracketed "pretty" breaks; the endpoints always
match the plotted \code{z_limits} range.}

\item{z_limits}{Optional numeric length-2 vector \code{c(zmin, zmax)} with \code{zmin < zmax}.
If provided, controls both:
\itemize{
  \item the surface range (data are clipped to these limits), and
  \item the legend range (same limits, with out-of-bounds values squished).
}
If \code{NULL}, uses the finite range of \code{data[[z_var]]}.}

\item{panel_size_in}{Numeric scalar. Intended width (inches) used to size the legend bar.
(The plot panel sizing returned in \code{$width} and \code{$height} is handled separately.)}

\item{legend_barheight_in}{Numeric scalar. Legend bar height in inches.}

\item{text_size}{Numeric scalar scaling factor applied to theme text sizes.}

\item{facet}{Logical. If \code{TRUE}, facet the surface using \code{facet_wrap()} by
\code{facet_by}.}

\item{facet_by}{Character scalar. Column name used for faceting when \code{facet=TRUE}.}

\item{facet_levels}{Optional character vector specifying facet level order and/or subset.
When provided, \code{data} are filtered to these levels and coerced to a factor with
\code{levels = facet_levels}.}
}
\value{
A list with three elements:
\describe{
  \item{\code{p}}{A \code{ggplot} object (filled contour surface).}
  \item{\code{width}}{Recommended output width in inches (numeric scalar).}
  \item{\code{height}}{Recommended output height in inches (numeric scalar).}
}

The returned ggplot object \code{p} includes metadata attributes used by overlay/helper
functions:
\itemize{
  \item \code{threshold}
  \item \code{x_breaks}, \code{y_breaks}
  \item \code{z_limits}
  \item \code{contour_breaks}
  \item \code{x_var}, \code{y_var}, \code{z_var}
}
}
\description{
Creates the base **climate response surface** (stress-test grid) as a filled contour plot.
This function plots only the surface (impacts as a function of two climate drivers) and
does **not** overlay GCM points; use your overlay helper for that.

The surface is rendered with discrete filled contour bins (via
\code{\link[ggplot2:geom_contour_filled]{geom_contour_filled()}}) and a diverging palette
centered on a user-defined or inferred \code{threshold}. A bold contour line is drawn at
the threshold to delineate the transition boundary.

The legend and surface share the same \code{z_limits} range (if provided). Values outside
\code{z_limits} are clipped to the range before plotting, and the legend is squished to
the same limits.
}
\details{
\strong{Threshold inference.} If \code{threshold=NULL}, the function searches for baseline
points where \code{x_var} and \code{y_var} are approximately zero (tolerance \eqn{1e-10})
and uses the mean \code{z_var} at those points. If none exist, an error is raised.

\strong{Color scaling.} The diverging palette is constructed so that there is exactly one
pure-white step at the threshold boundary. The mapping flips depending on \code{failure_dir}.

\strong{Legend labels.} The legend uses contour breaks; labels are thinned if necessary but
always include the minimum and maximum break, and a label at (or immediately below) the
threshold break.
}
\examples{
\dontrun{
grid <- expand.grid(
  dP = seq(-30, 30, by = 10),
  dT = seq(-2, 4, by = 1)
)
grid$impact <- 100 + 2 * grid$dT - 0.4 * grid$dP

out <- climate_surface_base(
  data = grid,
  x_var = "dP",
  y_var = "dT",
  z_var = "impact",
  threshold = 100,
  n_contours = 21,
  z_limits = c(80, 120)
)

out$p
}

}
