% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surface_weights_kde.R
\name{compute_scenario_surface_weights_kde}
\alias{compute_scenario_surface_weights_kde}
\title{Calculate climate-informed scenario weights using 2D KDE}
\usage{
compute_scenario_surface_weights_kde(
  ensemble_data,
  scenario_grid,
  pr_col = "prcp",
  ta_col = "tavg",
  group_col = "scenario",
  bw = NULL,
  bw_method = c("auto", "plugin", "nrd"),
  k = c(1.5, 2),
  alpha = 1,
  bw_min = c(0, 0),
  bw_max = c(Inf, Inf),
  min_samples = 5L,
  normalize = TRUE,
  area_weight = c("regular", "none"),
  scale = c("none", "global", "by_group"),
  weights_col = NULL,
  support = NULL,
  chunk_size = 5000L,
  diagnostics = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{ensemble_data}{Data frame with ensemble projections. Must contain columns
`ta_col`, `pr_col`, and `group_col`. Rows with non-finite `ta` or `pr` are ignored.}

\item{scenario_grid}{Data frame defining the evaluation grid. Must contain columns
`ta_col` and `pr_col`. All rows are evaluated.}

\item{pr_col}{Character scalar; name of precipitation column in both inputs. Units: `pr units`.}

\item{ta_col}{Character scalar; name of temperature column in both inputs. Units: `ta units`.}

\item{group_col}{Character scalar; name of grouping column in `ensemble_data`
(e.g., scenario/SSP). One output weight column is produced per group.}

\item{bw}{Optional numeric length-2 bandwidth vector `c(bw_ta, bw_pr)` in the
**original units**. If `scale != "none"`, the bandwidth is internally scaled
to the evaluation scale. Must be strictly positive.}

\item{bw_method}{Bandwidth selection method used when `bw` is `NULL`.
One of `"auto"`, `"plugin"`, `"nrd"`. See Details.}

\item{k}{Numeric length-2; grid-step multipliers used for bandwidth floor.
Dimensionless. Larger values enforce smoother KDE relative to grid resolution.}

\item{alpha}{Numeric scalar > 0; multiplier applied to the data-driven bandwidth
estimate before combining with the grid floor.}

\item{bw_min}{Numeric length-2; elementwise lower bounds for bandwidth (>= 0) in
the **original units**, later scaled if applicable.}

\item{bw_max}{Numeric length-2; elementwise upper bounds for bandwidth (> 0 or `Inf`)
in the **original units**, later scaled if applicable.}

\item{min_samples}{Integer; minimum number of complete observations required per
group after filtering. Must be >= 3.}

\item{normalize}{Logical; if `TRUE`, normalize each groupâ€™s weights to sum to 1
(after optional area-weighting and support masking). If `FALSE`, returns raw
evaluated densities (scaled by `1/(bw_ta*bw_pr)`).}

\item{area_weight}{Character; `"regular"` or `"none"`. Only applied when
`normalize = TRUE`. See Details.}

\item{scale}{Character; `"none"`, `"global"`, or `"by_group"`. Controls scaling
applied to the `(ta, pr)` space and grid before KDE evaluation.}

\item{weights_col}{Optional character scalar naming a column in `ensemble_data`
containing per-row weights. Weights are validated and renormalized within each
group after filtering to complete cases.}

\item{support}{Optional list specifying support bounds. Expected keys are `ta`
and/or `pr`, each a numeric length-2 range `c(min, max)` in the **original units**.
Grid points outside support are set to zero.}

\item{chunk_size}{Integer; number of grid rows evaluated per chunk. Larger values
are faster but use more memory due to `outer()` allocations.}

\item{diagnostics}{Logical; if `TRUE`, attaches diagnostic attributes (see Details).}

\item{verbose}{Logical; if `TRUE`, prints per-group bandwidth info and emits
additional warnings (e.g., low effective sample size).}
}
\value{
A data frame with the original `scenario_grid` columns plus one numeric
  weight column per group. Weight columns are named using the group labels,
  with collision avoidance if necessary.
}
\description{
For each group (e.g., SSP), fits a 2D Gaussian product-kernel KDE to ensemble
points `(ta, pr)` and evaluates it on `scenario_grid`. If `normalize = TRUE`,
returns a discrete probability mass function (PMF) over grid points (optionally
scaled by grid-cell area for regular grids).
}
\details{
**What is computed**
- Let observations be `(ta_i, pr_i)` with weights `w_i` (either uniform or taken
  from `weights_col`, then renormalized to sum to 1 after filtering).
- For each grid point `(T, P)`, compute
  \deqn{ \hat{f}(T, P) = \frac{1}{bw_{ta}\,bw_{pr}} \sum_i w_i \, \phi\!\left(\frac{T-ta_i}{bw_{ta}}\right)\,
  \phi\!\left(\frac{P-pr_i}{bw_{pr}}\right) }
  where `phi()` is the standard normal density.

**Scaling**
- `scale = "none"` evaluates in the original units.
- `scale = "global"` applies one global scaling (derived in grid context).
- `scale = "by_group"` applies scaling per group.
Scaling affects bandwidth selection and evaluation because it changes units.

**Area weighting (only when `normalize = TRUE`)**
- If `area_weight = "regular"`, weights are multiplied by `(dT * dP)` prior to
  normalization, where `dT` and `dP` are grid steps in the evaluation scale.
- If `area_weight = "none"`, normalization is over raw evaluated densities.

**Support masking**
- If `support` is provided, grid points outside support are set to zero after
  evaluation. If all grid points are outside support, a warning is emitted and
  the returned weight column for that group will be all zeros (after masking).

**Diagnostics**
When `diagnostics = TRUE`, attributes are attached:
- `"bandwidth_used"`: per-group bandwidths used.
- `"bandwidth_method"`: `"user"` or the selected automatic method.
- `"effective_sample_size"`: Kish effective sample size computed from raw weights.
- `"scaling_params"`: scaling mode and per-group scaling factors.

**Failure / skip conditions**
Groups are skipped (with a warning) when:
- fewer than `min_samples` complete `(ta, pr)` pairs remain,
- near-zero variance in `ta` or `pr`,
- automatic bandwidth selection fails.
Skipped groups are recorded in `attr(out, "skipped_groups")`.
}
\examples{
set.seed(1)
ensemble_data <- data.frame(
  scenario = rep(c("SSP1", "SSP2"), each = 30),
  tavg = c(rnorm(30, 0, 1), rnorm(30, 1, 1)),
  prcp = c(rnorm(30, 0, 1), rnorm(30, 0.5, 1))
)

scenario_grid <- expand.grid(
  tavg = seq(-3, 3, length.out = 50),
  prcp = seq(-3, 3, length.out = 50)
)

w <- compute_scenario_surface_weights_kde(
  ensemble_data = ensemble_data,
  scenario_grid = scenario_grid,
  ta_col = "tavg",
  pr_col = "prcp",
  group_col = "scenario",
  normalize = TRUE,
  area_weight = "none",
  verbose = FALSE
)
head(w)

}
